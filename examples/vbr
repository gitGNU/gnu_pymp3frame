#!/usr/bin/python
#
# Copyright (c) 2005,2008 Michael Gold
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import division
import mp3frame.sync, mp3frame.frames
import getopt
import sys
import struct
import os.path
import array

def make_xing_frame(frames, template_header, abr, start_offset, eof_pos):
	# The header from the file's first music frame is used as a template
	# for the VBR frame header. The bitrate is changed to be as close as
	# possible to the average bitrate.
	
	# All frame positions will increase by 'start_offset' bytes when
	# writing the file (this can be negative, meaning an existing VBR
	# header is being stripped). The size of the header generated by
	# this function is automatically added.
	
	newhead = template_header
	newhead.protection_bit = 1  # disable CRC
	
	# try each bitrate, attempting to match the average
	newhead.bitrate_index = 0xe  # maximum bitrate
	best = (newhead.bitrate_index, 999000)  # start with max values
	while newhead.bitrate_index > 0:
		brdiff = abs(abr - newhead.bitrate)
		if brdiff < best[1]:
			best = (newhead.bitrate_index, brdiff)
		newhead.bitrate_index -= 1
	
	newhead.bitrate_index = best[0]
	
	# set up the Xing header
	xing_header = mp3frame.frames.XingHeader()
	xing_header.cbr_mode = False
	xing_header.frame_count = len(frames)
	xing_header.byte_count = 0  # filled in later
	xing_header.seek_table = toc = []
	xing_header.quality = None
	xing_header.extended_data = None
	
	# make sure the data will fit in the frame
	datasize = 4 + newhead.side_info_size + xing_header.calc_size()
	while newhead.frame_size < datasize:
		assert newhead.bitrate_index != 0xe  # max bitrate should be enough
		newhead.bitrate_index += 1
	
	# this VBR header frame will be inserted before any music frames
	start_offset += newhead.frame_size
	eof_pos += start_offset
	xing_header.byte_count = eof_pos
	
	# create the TOC
	for i in range(100):
		fr_start = frames[i * len(frames) // 100] + start_offset
		toc.append( min(255, fr_start * 256 // eof_pos) )
	assert len(toc) == 100
	
	# create a frame and put the Xing header into it
	frame = mp3frame.frames.MP3Frame()
	frame.header = newhead
	frame.init()
	#frame.side_info.fromstring('\0' * newhead.side_info_size)
	frame.body = array.array('B')
	xing_header.encode(frame)
	return frame


#########################


def usage_err_exit(message):
	print >> sys.stderr, "%s: %s" % (sys.argv[0], message)
	print >> sys.stderr, \
			"Try `%s --help' for more information." % (sys.argv[0],)
	sys.exit(2)


def fix_mp3(filename, output_filename, analyze):
	print "Reading file: %s" % filename
	mp3file = file(filename, "rb")
	
	## find the position of each frame (except VBR header frames)
	
	chop = 0
	pos = 0
	frames = []
	first_frame_header = None
	s = mp3frame.sync.FileSyncWrapper(
			mp3frame.sync.PhysicalFrameSync(), mp3file)
	br_tot = 0
	cbr = None
	for (typ, item) in s.items():
		if typ == 'frame':
			if item.header.layer_index != 1:
				print >> sys.stderr, 'Not an MPEG layer 3 audio file'
				sys.exit(1)
			elif not frames and item.identify_vbr_header():
				# this is a VBR header frame, and we'll remove it
				chop += len(item)
			else:
				assert pos == item.byte_position
				frames.append(pos)
				head = item.header
				br = head.bitrate
				
				br_tot += br
				if first_frame_header is None:
					first_frame_header = head
					cbr = br
				elif cbr and (br != cbr):
					cbr = None
		
		pos += len(item)
	
	## create the VBR header frame
	
	eof_pos = pos
	if not frames:
		print >> sys.stderr, 'No music frames found'
		sys.exit(1)
	
	if frames: abr = br_tot / len(frames)
	else: abr = None
	
	if cbr:
		print >> sys.stderr, 'Constant bitrate: %d kbps' % (cbr // 1000)
		new_xing_frame = None
	else:
		print >> sys.stderr, 'Average bitrate: %.2f kbps' % (abr / 1000)
		new_xing = make_xing_frame(frames,
				first_frame_header, abr, -chop, eof_pos)
	
	if analyze:
		if chop:
			print 'Would remove %d bytes of VBR header data' % chop
		if new_xing:
			print 'Would add %d-byte VBR header' % len(new_xing)
		
		if not chop and not new_xing:
			print 'No changes necessary'
		
		return
	
	if not chop and not new_xing:
		print 'Nothing to do; no output file written'
		return
	
	
	## write out the file, adding the header frame
	
	if output_filename == '-':
		outfile = sys.stdout
	else:
		if not output_filename:
			(root, ext) = os.path.splitext(filename)
			if ext.lower() == '.mp3':
				# strip file extension
				output_filename = root
			else:
				output_filename = filename
			
			output_filename += '.out.mp3'
		
		outfile = file(output_filename, 'wb')
	
	print 'Writing output file: %s' % output_filename
	
	mp3file.seek(0)
	s.sync = mp3frame.sync.PhysicalFrameSync()
	for (typ, item) in s.items():
		if typ == 'frame':
			if item.identify_vbr_header():
				continue
			
			# insert the Xing header before the first audio frame
			if new_xing:
				new_xing.tofile(outfile)
				new_xing = None
		
		# write out frames as well as other items
		item.tofile(outfile)
	
	mp3file.close()
	outfile.close()


def opt_value(opt_dict, *keys):
	stored = None
	for k in keys:
		if k in opt_dict:
			if stored != None:
				conflict = [stored[0], k]
				conflict.sort()
				usage_err_exit("options %s and %s conflict" %
						tuple(conflict) )
			
			stored = (k, opt_dict[k])
	
	if stored == None: return None
	else: return stored[1]


def main():
	try:
		opt = {}
		optlist, args = getopt.gnu_getopt(sys.argv[1:], 'o:a',
				['help', 'output-file=', 'analyze'])
		for (key, value) in optlist:
			if key in opt:
				usage_err_exit(
						"option %s used multiple times" % key)
			
			opt[key] = value
	except getopt.GetoptError, e: usage_err_exit(e)
	
	if opt_value(opt, '-h', '--help') != None:
		print "Usage: %s [OPTION] MP3FILE"
		print "Read MP3FILE and add a varible bitrate header."
		print "Outputs to MP3FILE.out.mp3 by default."
		print
		print "  -a, --analyze              don't write any output"
		print "  -o, --output-file=OUTFILE  write output to OUTFILE"
		print "      --help                 display this help and exit"
		sys.exit(0)
	
	output_file = opt_value(opt, '-o', '--output-file')
	analyze = (opt_value(opt, '-a', '--analyze') != None)
	if analyze and output_file:
		usage_err_exit("--output-file not allowed"
				" when using --analyze")
	
	if len(args) == 0: usage_err_exit("missing filename")
	elif len(args) > 1 and output_file:
		usage_err_exit("only one input file allowed"
				" when using --output-file option")
	
	first = 1
	for input_file in args:
		if first: first = 0
		else: print
		fix_mp3(input_file, output_file, analyze)


if __name__ == "__main__":
	main()
