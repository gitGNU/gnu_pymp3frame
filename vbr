#!/usr/bin/python
#
# Copyright (c) 2005 Michael Gold
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import division
import mp3frame, mp3bits
import getopt
import sys
import struct

bufsize = 65536

def copy_file(src, dst, length=None):
	# if length==None, go until EOF
	
	copied = 0
	while 1:
		if length == None:
			buf = src.read(bufsize)
			if not buf: break  # EOF
		else:
			data_left = length - copied
			if data_left <= 0: break
			
			buf = src.read(min(bufsize, data_left))
			if not buf: raise IOError('hit EOF while reading data')
		
		dst.write(buf)
		copied += len(buf)

def make_xing_header(frames, template_frame, abr, start_offset, eof_pos):
	# the header from the file's first music frame is used as a template
	# for the VBR frame header. the bitrate is changed to be as close as
	# possible to the average bitrate.
	
	# all frame positions will increase by 'start_offset' bytes when
	# writing the file (this can be negative, meaning an existing VBR
	# header is being stripped).
	
	newhead = mp3frame.Header(template_frame.header, mutable=1)
	
	# TODO: add CRC16 code to support protected frames
	newhead.protected = 0
	
	# try each bitrate, attempting to match the average
	best = (0xe, 640000)  # start with max values
	newhead.bitrate_index = best[0]
	while 1:
		brdiff = abs(abr - newhead.bitrate)
		if brdiff < best[1]:
			best = (newhead.bitrate_index, brdiff)
		if newhead.bitrate_index == 1: break
		newhead.bitrate_index -= 1
	
	newhead.bitrate_index = best[0]
	sideinfo_offset = newhead.side_info_size
	
	# make sure the data will fit in the frame
	#TODO: allow user-specified tag to replace padding bytes
	datasize = 4 + sideinfo_offset + 120
	while newhead.frame_size < datasize:
		if newhead.bitrate_index == 0xe:
			raise ValueError("couldn't create enough space"
					" to store the VBR header")
		# increase frame size
		newhead.bitrate_index += 1
	
	# this VBR header frame will be inserted before any music frames
	start_offset += newhead.frame_size
	eof_pos += start_offset
	
	# create the TOC
	toc = ''
	for i in range(100):
		fr_start = frames[i * len(frames) // 100] + start_offset
		toc += chr(min(255, fr_start * 256 // eof_pos))
	
	# create the Xing header
	xingbody = ('\0' * sideinfo_offset) + 'Xing' \
			+ struct.pack('!III', 0x7, len(frames), eof_pos) \
			+ toc + struct.pack('!I',0) \
			+ ('\0' * (newhead.frame_size - datasize))
	return newhead.binary_str + xingbody

#########################


def usage_err_exit(message):
	print >> sys.stderr, "%s: %s" % (sys.argv[0], message)
	print >> sys.stderr, \
			"Try `%s --help' for more information." % (sys.argv[0],)
	sys.exit(2)

def fix_mp3(filename, output_filename, analyze):
	print "Reading file: %s" % filename
	mp3file = file(filename, "rb")
	
	mp3file.seek(0)
	sc = mp3frame.Scanner(mp3file)
	last_end = 0
	
	# TODO: provide options to remove or preserve non-music data
	#  including:
	#    -id3 frames
	#    -id3v2
	#    -existing VBR headers (e.g. VBRI)
	#    -unknown data
	junk = []
	def found_junk(size, pos_str):
		junk.append((pos_str, size))
		print >> sys.stderr, "Preserving %s bytes of non-music data" \
				" at %s" % (size, pos_str)
	
	# first_fr always holds the *original* first frame,
	# even if it gets removed from frames[] later
	first_frame = None
	first_music_frame = None
	frames = []
	br_tot = 0
	for fr in sc:
		head = fr.header
		if first_music_frame == None:
			if first_frame == None: first_frame = fr
			# this can equal first_fr
			
			if not fr.is_vbr_header():
				first_music_frame = fr
				cbr = head.bitrate
		
		pos = fr.pos
		if pos > last_end:
			found_junk(fr.pos - last_end, "byte position %d" % last_end)
			last_end = pos
		
		if first_music_frame != None: # ignore non-music frames
			frames.append(pos)
			bitrate = head.bitrate
			br_tot += bitrate
			if cbr and (bitrate != cbr): cbr = None
		
		last_end += head.frame_size
	
	if not frames:
		print >> sys.stderr, 'No music frames found'
		sys.exit(1)
	
	if frames: abr = br_tot / len(frames)
	else: abr = None
	
	eof_pos = sc.buffer_start + len(sc.buffer)
	if eof_pos != last_end:
		found_junk(eof_pos - last_end, "end of file")
	
	chop = first_music_frame.pos - first_frame.pos
	if cbr:
		print >> sys.stderr, 'Constant bitrate: %d kbps' % (cbr // 1000)
		new_xing = ''
	else:
		print >> sys.stderr, 'Average bitrate: %.2f kbps' % (abr / 1000)
		new_xing = make_xing_header(frames, first_music_frame,
				abr, -chop, eof_pos)
	
	if analyze:
		if chop:
			print 'Would remove %d bytes of VBR header data' % chop
		if new_xing:
			print 'Would add %d-byte VBR header' % len(new_xing)
		
		if not chop and not new_xing:
			print 'No changes necessary'
		
		return
	
	if not chop and not new_xing:
		print 'Nothing to do; no output file written'
		return
	
	#############################################################
	
	# TODO: add options for stripping non-music data
	#   note: removals would need to be calculated before creating
	#         the VBR header
	# TODO: exit if there's no work to do
	
	if output_filename == '-':
		outfile = sys.stdout
	else:
		if not output_filename:
			if filename[-4:].lower() in ('.mp3', '.mp2', '.mp1'):
				# strip file extension
				output_filename = filename[:-4]
			else:
				output_filename = filename
			
			# name files as x.out.mp3 (or mp2, etc.)
			output_filename += '.out.mp' \
					+ str(first_music_frame.header.layer)
		
		outfile = file(output_filename, 'wb')
	
	print 'Writing output file: %s' % output_filename
	
	# copy beginning junk (id3v2)
	mp3file.seek(0)
	copy_file(mp3file, outfile, first_frame.pos)
	
	# write Xing header if needed
	if new_xing: outfile.write(new_xing)
	
	# copy MP3 frames and ending junk (id3v1)
	mp3file.seek(frames[0])
	copy_file(mp3file, outfile)
	
	mp3file.close()
	outfile.close()

def opt_value(opt_dict, *keys):
	stored = None
	for k in keys:
		if k in opt_dict:
			if stored != None:
				conflict = [stored[0], k]
				conflict.sort()
				usage_err_exit("options %s and %s conflict" %
						tuple(conflict) )
			
			stored = (k, opt_dict[k])
	
	if stored == None: return None
	else: return stored[1]

def main():
	try:
		opt = {}
		optlist, args = getopt.gnu_getopt(sys.argv[1:], 'o:a',
				['help', 'output-file=', 'analyze'])
		for (key, value) in optlist:
			if key in opt:
				usage_err_exit(
						"option %s used multiple times" % key)
			
			opt[key] = value
	except getopt.GetoptError, e: usage_err_exit(e)
	
	if opt_value(opt, '-h', '--help') != None:
		print "Usage: %s [OPTION] MP3FILE"
		print "Read MP3FILE and add a varible bitrate header."
		print "Outputs to MP3FILE.out.mp3 by default."
		print
		print "  -a, --analyze              don't write any output"
		print "  -o, --output-file=OUTFILE  write output to OUTFILE"
		print "      --help                 display this help and exit"
		sys.exit(0)
	
	output_file = opt_value(opt, '-o', '--output-file')
	analyze = (opt_value(opt, '-a', '--analyze') != None)
	if analyze and output_file:
		usage_err_exit("--output-file not allowed"
				" when using --analyze")
	
	if len(args) == 0: usage_err_exit("missing filename")
	elif len(args) > 1 and output_file:
		usage_err_exit("only one input file allowed"
				" when using --output-file option")
	
	first = 1
	for input_file in args:
		if first: first = 0
		else: print
		fix_mp3(input_file, output_file, analyze)

if __name__ == "__main__":
	main()
	
	#for x in range(10000000):pass
	#print 'st'
	#import hotshot, hotshot.stats
	#prof = hotshot.Profile("vbr.prof")
	#benchtime = prof.runcall(main)
	#prof.close()
	#stats = hotshot.stats.load("vbr.prof")
	#stats.strip_dirs()
	#stats.sort_stats('time', 'calls')
	#stats.print_stats(20)
